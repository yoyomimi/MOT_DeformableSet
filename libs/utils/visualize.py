import numpy as np


def getDistinguishableColors(numColors, bgColors=[(1, 1, 1)]):
    """Pick a set of `numColors` colors that are maximally perceptually distinct.

    When plotting a set of lines/curves/points, you might want to distinguish them
    by color. This module generates a set of colors that are ``maximally perceptually
    distinguishable`` in the RGB colorspace. Given an initial seed list of candidate colors,
    it iteratively picks the color from the list that is the farthest (in the RGB colorspace)
    from all previously chosen entries. This is a ``greedy`` method and does not yield
    a global maximum.

    Inspired by the MATLAB implementation from Timothy E. Holy.

    Args:
            numColors (int): number of distinguishable colors to generate
            bgColors (:obj:`list`, optional): list of background colors

    Returns:
            colors (:obj:`list`): list of `numColors` distinguishable colors

    Examples:
            >>> colors = getDistinguishableColors(25)
    """

    # Start out by generating a sizeable number of RGB triples. This represents our space
    # of possible choices. By starting out in the RGB space, we ensure that all of the colors
    # can be generated by the monitor.

    # Number of grid divisions along each axis in RGB space
    numGrid = 30
    x = np.linspace(0, 1, numGrid)
    [R, G, B] = np.meshgrid(x, x, x)
    rgb = np.concatenate((R.T.reshape((numGrid * numGrid * numGrid, 1)),
                          G.T.reshape((numGrid * numGrid * numGrid, 1)),
                          B.T.reshape((numGrid * numGrid * numGrid, 1))), axis=1)
    if numColors > rgb.shape[0] / 3:
        raise ValueError(
            'You cannot really distinguish that many colors! At most 9000 colors')

    # If the user specified multiple bgColors, compute distance from the candidate colors
    # to the background colors.
    mindist = np.full(rgb.shape[0], np.inf)
    for c in bgColors:
        col = np.full(rgb.shape, 1)
        col[:, 0] = c[0]
        col[:, 1] = c[1]
        col[:, 2] = c[2]
        dx = np.sum(np.abs(rgb - col), axis=1)
        mindist = np.minimum(mindist, dx)

    # Initialize a list of colors
    colors = []
    lastColor = bgColors[-1]
    for i in range(numColors):
        col = np.full(rgb.shape, 1)
        col[:, 0] = lastColor[0]
        col[:, 1] = lastColor[1]
        col[:, 2] = lastColor[2]
        dx = np.sum(np.abs(rgb - lastColor), axis=1)
        mindist = np.minimum(mindist, dx)
        index = np.argmax(mindist)
        chosenColor = (rgb[index, 0], rgb[index, 1], rgb[index, 2])
        colors.append(chosenColor)
        lastColor = chosenColor
    return colors